# -*- coding: utf-8 -*-
"""Untitled12.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1j0ClDn_KJY-SNGfnIaymJ1NAqu9G_njx
"""

# install kaggle package
!pip install -q kaggle

"""Nama: Putri Wulandari

Kelas: Machine Learning dan Front End

Proyek Akhir : Image Classification Model Deployment

BISMILLAH DIACC
"""

# upload kaggleee

from google.colab import files
files.upload()

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json
!ls ~/.kaggle

!kaggle datasets download -d madisona/translated-animals10

# UNZIP
!mkdir animales
!unzip -qq translated-animals10.zip -d animales
!ls animales

#MEMBUKA FOLDER
!ls animales/animals10/raw-img/

import os

animales = os.path.join('/content/animales/animals10/raw-img')

print(os.listdir(animales))

import shutil

ignore_animales = ['spider', 'dog', 'squirrel', 'cat', 'chicken', 'sheep']

for x in ignore_animales:
  path = os.path.join(animales, x)
  shutil.rmtree(path)

list_animales = os.listdir(animales)
print(list_animales)

from PIL import Image
total = 0

for x in list_animales:
  dir = os.path.join(animales, x)
  y = len(os.listdir(dir))
  print(x+':', y)
  total = total + y
  
  img_name = os.listdir(dir)
  for z in range(4):
    img_path = os.path.join(dir, img_name[z])
    img = Image.open(img_path)
    print('-',img.size)
  print('---------------')

print('\nTotal :', total)

import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots(2, 2, figsize=(15,15))
fig.suptitle("Randomly displays images.", fontsize=24)
animales_sorted = sorted(list_animales)
animales_id = 0
for i in range(2):
  for j in range(2):
    try:
      animales_selected = animales_sorted[animales_id] 
      animales_id += 1
    except:
      break
    if animales_selected == '.TEMP':
        continue
    animales_selected_images = os.listdir(os.path.join(animales, animales_selected))
    animales_selected_random = np.random.choice(animales_selected_images)
    img = plt.imread(os.path.join(animales, animales_selected, animales_selected_random))
    ax[i][j].imshow(img)
    ax[i][j].set_title(animales_selected, pad=10, fontsize=22)
    
plt.setp(ax, xticks=[],yticks=[])
plt.show

from tensorflow.keras.preprocessing.image import ImageDataGenerator
 
train_datagen = ImageDataGenerator(
    rotation_range=40,
    width_shift_range=0.2,
    height_shift_range=0.2,
    rescale=1/255,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest',
    validation_split=0.2   
)

batch_size = 256

data_train = train_datagen.flow_from_directory(
    animales,
    target_size=(150, 150),
    batch_size=batch_size,
    class_mode='categorical',
    subset='training')

data_val = train_datagen.flow_from_directory(
    animales, 
    target_size=(150, 150),
    batch_size=batch_size,
    class_mode='categorical',
    subset='validation')

import tensorflow as tf
# from tensorflow.keras import applications, optimizers

tf.device('/device:GPU:0')

model = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(64, (3,3), activation='relu', input_shape=(150, 150, 3)),
    tf.keras.layers.MaxPooling2D(2, 2),
    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Conv2D(128, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Conv2D(128, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dropout(0.5), 
    tf.keras.layers.Dense(512, activation='relu'),
    tf.keras.layers.Dense(4, activation='softmax')
])

model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics = ['accuracy'])

model.summary()

# Penggunaan Callback mencegah overfitting dan menghentikan training setelah akurasi terpenuhi
class CNNCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if(logs.get('accuracy') > 0.92 and logs.get('val_accuracy')>0.92):
      print("\nAkurasi di atas 92%, dihentikan Sekarang yaaa!")
      self.model.stop_training = True

callbacks = CNNCallback()

# compile model dengan 'adam' optimizer loss function 'categorical_crossentropy' 

model.compile(loss='categorical_crossentropy',
              optimizer=tf.optimizers.Adam(),
              metrics=['accuracy'])

history = model.fit(
    data_train,
    steps_per_epoch = 25, # 1312 images = batch_size * steps
    epochs = 15,
    validation_data = data_val,
    validation_steps = 5, # 876 images = batch_size * steps
    verbose =1,
      callbacks=[callbacks],
    
)

#AKURASI PLOT
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title('Accuracy')
plt.ylabel('accuracy')
plt.xlabel('epoch')
plt.legend(['train', 'val'], loc='upper left')
plt.show()

#VALIDAsi dan Training
plt.plot(history.history['loss'], label='Training', color='blue')
plt.plot(history.history['val_loss'], label='Validation', color='red')
plt.title('Loss Training & Validation')
plt.xlabel('Epoch')
plt.legend(loc="upper right")
plt.show()

from sklearn.metrics import classification_report, confusion_matrix, ConfusionMatrixDisplay
import matplotlib.pyplot as plt
import numpy as np

# Defining list with labels
labels = ['elephant', 'butterfly', 'horse', 'cow']

# Check point
# Showing labels
print(labels)

# Generating Numpy array with True classes' indexesss
y_true = np.random.randint(low=0, high=5, size=100, dtype=int)


# Check point
# Showing array
print(y_true)

# Calculating number of samples for every classss
# Iterating all classes' indexes in 'y_true' arrayyy
# Using Numpy function 'unique'
# Returning sorted unique elements and their frequenciesss

classesIndexes, classesFrequency = np.unique(y_true, return_counts=True)


# Printing frequency (number of samples) for every class
print('classes indexes:' , classesIndexes)
print('\n')
print('classes frequency:', classesFrequency)

# Making copy of array with True classes' indexess

y_predicted = np.copy(y_true)

# Choosing randomly 25% of classes to be changedd
ii = np.random.randint(low=0, high=len(y_true), size=int(0.25 * len(y_true)), dtype=int)


# Check pointt
# Showing chosen indexess
print(ii)

# Iteratinggg chosen indexes and replacing them with other classes' indexes
for i in ii:

    # Generating new class index
    y_predicted[i] = np.random.randint(low=0, high=5, dtype=int)
    
    
    # Check pointt
    # Showing difference between True classes' indexes and Predicted oness
    print('index = {0:2d}, True class => {1}, {2} <= Predicted class'.
          format(i, y_true[i], y_predicted[i]))

# Confusion Matrix is a two dimensional matrix that visualizes the performance,,
# and makes it easy to see confusion between classes,,
# by providing a picture of interrelationn

# Each row represents a number of actual, True class
# Each column represents a number of predicted classs

# Computing Confusion Matrix to evaluate accuracy of classificationnnn
c_m = confusion_matrix(y_true, y_predicted)

# Showing Confusion Matrix in form of 2D Numpy arrayyy
print(c_m)

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline


# Settingg default size dari the plott
# Settingg default fontsize used in the plot
plt.rcParams['figure.figsize'] = (10.0, 9.0)
plt.rcParams['font.size'] = 20


# Implementinggg visualization of Confusion Matrix
display_c_m = ConfusionMatrixDisplay(c_m, display_labels=labels)


# Plotting Confusion Matrixxx
# Setting colour map to be useddd
display_c_m.plot(cmap='OrRd', xticks_rotation=25)
# Other possible options for colour map are:
# 'autumn_r', 'Blues', 'cool', 'Greens', 'Greys', 'PuRd', 'copper_r'


# Settinggg fontsize for xticks and yticks
plt.xticks(fontsize=15)
plt.yticks(fontsize=15)


# Giving name to the plott
plt.title('Confusion Matrix', fontsize=24)


# Saving plott
plt.savefig('confusion_matrix.png', transparent=True, dpi=500)


# Showing the plott
plt.show()

# Showing the main classification metricsss

print(classification_report(y_true, y_predicted))

import pathlib

# Menyimpan model dalam format SavedModelll
export_dir = 'saved_model/'
tf.saved_model.save(model, export_dir)
 
# Convert SavedModel menjadi Rice Deseased.tflitee
converter = tf.lite.TFLiteConverter.from_saved_model(export_dir)
tflite_model = converter.convert()
 
tflite_model_file = pathlib.Path('Rice_Desease.tflite')
tflite_model_file.write_bytes(tflite_model)